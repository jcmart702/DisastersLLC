#!/usr/bin/env node --harmony

'use strict'
const dotenv = require('nvar');
const path = require('path')
const glob = require('glob') // From browsersync.
const program = require('commander')
const SAM = require('../')
const pkg = require('../package.json')

let cwd = process.cwd()

program
  .version(pkg.version)
  .arguments('[directory]')
  .action(directory => {
    if (directory) {
      cwd = directory
    }
    dotenv({path: path.resolve(cwd, '.env')})
  })
  .option('-d, --database <url>', 'Database URL to read data from.')
  .option('-p, --port [port]', 'The port SAM listens to. Default: random.', (v) => parseInt(v, 10), process.env.PORT || 0)
  .option('-e, --max-age [seconds]', 'Token expiration. Default: 3600.', (v) => parseInt(v, 10), process.env.AUTH_DURATION || 60 * 60)
  .option('-m, --memory', 'Keep most recent page in memory.')
  .option('-C, --no-cache', 'Do not cache the XML into file system.')
  .option('-w, --watch <glob>', 'A glob pattern for files to watch. Supports multiple instances.', (pattern, patterns) => {
    patterns.push(pattern)
    return patterns
  }, [])
  .option('-hk, --hook <module>', 'Optional module to call on events')
  .option('-t, --tunnel', 'Provide tunnel to the outside world.')

program.parse(process.argv)

// Set default values;
program.port = program.port || process.env.PORT || 0
program.maxAge = program.maxAge || process.env.AUTH_DURATION || 60 * 60

// Port will be either -p value, process.env.PORT, or 0, in that order.
const targetPort = program.port
const watch = program.watch

const app = new SAM({
  databaseUrl: program.database,
  cwd: cwd,
  useMemory: program.memory,
  useCache: program.cache,
  tokenMaxAge: program.maxAge,
  hook: program.hook
})

// If watching is not needed, use `port` so it will listen to correct
// port; otherwise, we don't care which port, as long as we know the
// chosen port to proxy from target port to.
app.listen(watch.length ? 0 : targetPort, function () {
  const SAMPort = this.address().port

  if (watch.length) {
    const browserSync = require('browser-sync').create('SAM:watcher')
    const hook = program.hook
    const watchConfigs = watch.map((pattern, index) => {
      const config = {
        match: [pattern]
      }
      if (hook) {
        // Set up custom callback to trigger our hook.
        try {
          const transform = require(path.resolve(cwd, hook))
          config.fn = function triggerHook(event, filePath) {
            const fullPath = path.join(cwd, filePath)
            transform(event, fullPath)

            // Manually reload related files.
            const files = glob.sync(pattern, {cwd: cwd})
            browserSync.reload(files)
          }
        } catch(error) {
          console.error('Failed to load hook.', error)
        }
      }

      return config
    })

    browserSync.init({
      // When `-p` value is 0, the user did not specify any port.
      // Conveniently it is also `false`, and we then use `port` value
      // assigned by SAM instance.
      port: targetPort || SAMPort, // Actual port to use in browser.
      proxy: {
        target: 'localhost:' + SAMPort, // Port generated by BrowserSync. Can be same as above port.
        ws: true
      },
      tunnel: program.tunnel,
      open: false,
      files: watchConfigs,
      watchOptions: {
        cwd: cwd
      },
      watchEvents: ['add', 'change', 'unlink']
    })
  } else {
    console.log('SAM is listening to port', SAMPort)
  }
})

program.server = app

module.exports = program
