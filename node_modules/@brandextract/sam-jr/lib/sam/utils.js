const path = require('path')
const spawn = require('child_process').spawn
const libxmljs = require('libxmljs2')

const ObjProto = Object.prototype

exports.isEmpty = isEmpty
exports.isArray = Array.isArray || isArray
exports.isObject = isObject
exports.has = has

function isEmpty (obj) {
  if (obj == null) return true
  if (isArray(obj) ||
     (typeof obj === 'string')) return (obj.length === 0)
  for (var key in obj) if (has(obj, key)) return false
  return true
}

function isArray (obj) {
  return ObjProto.toString.call(obj) === '[object Array]'
}

function isObject (obj) {
  return typeof obj === 'function' || typeof obj === 'object' && !!obj
}

function has (obj, key) {
  return ObjProto.hasOwnProperty.call(obj, key)
}

function parseXml (xml, xpath) {
  let doc = libxmljs.parseXml(xml)
  if (xpath) {
    doc = doc.get(xpath)
  }
  return doc
}

exports.parseXml = parseXml

/**
 * Processes a XSL stylesheet with XML data.
 * @param {string} stylesheetPath The full path to the XSL stylesheet.
 * @param {object} params Key-value object of parameters.
 * @returns {Promise} The promise of transformed output.
 */
function transform(stylesheetPath, xml, params = {}) {
  return new Promise(function(resolve, reject) {
    const args = []

    Object.keys(params).forEach(name => {
      const value = params[name];
      if (typeof value === "undefined") return;

      args.push('--stringparam')
      args.push(name);
      args.push(value);
    });

    args.push(stylesheetPath)
    args.push(`-`) // Takes XML data from stdin.

    const xsltproc = spawn('/usr/bin/xsltproc', args)
    const buffer = []

    xsltproc.stdout.on('data', function(data) {
      buffer.push(data)
    });

    xsltproc.stdout.on('close', function(code) {
      if (!code) {
        resolve(Buffer.concat(buffer).toString())
      } else {
        reject(new Error('Exited with code: ' + code))
      }
    });

    xsltproc.stdout.on('error',  (error) => {
      console.error("stdout:", error)
      reject(new Error("stdout: " + error));
    })

    xsltproc.stderr.on('data', (error) => {
      console.error("stderr:", error.toString())
      reject(new Error("stderr: " + error));
    });

    xsltproc.stdin.on('error', (error) => {
      console.error("stdin:", error)
      reject(new Error("stdin: " + error));
    });

    xsltproc.stdin.write(xml.toString())
    xsltproc.stdin.end()
  });
}

exports.transform = transform

/**
 * Renders a template with variable substitutions.
 * @param {string} template The template string to render data into.
 * @param {object} data Object containing variable substitutions.
 *
 * Example:
 *    template('link[@leftPtr >= {$leftPtr} and @rightPtr <= {$rightPtr}]', {
 *      leftPtr: 2,
 *      rightPtr: 2179
 *    }) === 'link[@leftPtr >= 2 and @rightPtr <= 2179]'
 */

exports.template = async function (template, data) {
  let document = '<?xml version="1.0" encoding="utf-8"?><root>'

  Object.keys(data).forEach((key) => {
    document += `<${key}>${data[key].toString()}</${key}>`
  })
  document += `</root>`

  const result = await transform(
    path.join(__dirname, 'utils', 'template.xsl'),
    document,
    {selector: template}
  )

  return result
}
