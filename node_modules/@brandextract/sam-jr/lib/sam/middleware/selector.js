/* jslint         indent  : 2,    maxerr   : 50,
  esnext : true, -W030   : true, node     : true
*/
const debug = require('debug')('SAM:selector')

const XPath = require('js-xpath')
const utils = require('../utils')
const { parseXml, template } = utils

let CACHE = {}

/**
 * Selector middleware
 *
 * Allows selecting specific nodes of the XML, while hiding/masking
 * the rest.
 *
 * ## Example
 *
 *     GET /pages/1.xml?select=page|sites|navigation/link[@parent-id=1]
 *
 * Response:
 *
 *     <?xml version="1.0"?>
 *     <SAM copyright="2001-2011 BrandExtract" directive="admin" ...>
 *       <page id="1" ...>...</page>
 *       <sites ...>...</sites>
 *       <navigation>
 *         <link id="2" parent-id="1"...>...</link>
 *         <link id="3" parent-id="1"...>...</link>
 *         <link id="4" parent-id="1"...>...</link>
 *         <link id="5" parent-id="1"...>...</link>
 *       </navigation>
 *     </SAM>
 *
 * The difference between this and an XPath selector is that it
 * allows filtering of the selected nodes. Instead of returning the
 * full `page` and `navigation` nodes in the example above (because
 * there are `link` nodes in `navigation` that have `parent-id` attr
 * equals 1), this only returns the `link` nodes that match.
 *
 * @param  {String}   config.path The folder to get/save XML file to
 * @return {Function} The middleware function which sets the filtered
 *                    XML string in `context.body`.
 */

 // Syntax:
 //
 //  - `a[@attr]` will only select node when it has attribute `attr`
 //  - `a[@attr="foo"]` will only select node when it has attribute `attr` with value "foo"
 //  - `a|b|c` will select multiple nodes.
 //  - `a/b/c` will select a node from its parent.
 //  - `a/b|a/c` sub-selection will select many nodes from a parent.
 //  - `a/*/c` the star * wildcard will select all items in a field.
module.exports = (config = {}) => {
  /**
   * Applies a mask to a XML node.
   *
   * @param  {object} node The XML node
   * @param  {object} mask The parsed XPath selector
   * @return {void}
   */
  function apply (element, mask, stepNumber = 0) {
    const type = mask.type
    if (type === 'union') {
      apply(element, mask.left, stepNumber)
      apply(element, mask.right, stepNumber)
    } else {
      const step = mask.steps[stepNumber]
      let matchedNodes = element.find(step.toXPath())
      if (!matchedNodes) return

      matchedNodes.forEach((childElement) => {
        // We set a temporary attribute on the node so the cleanup knows.
        if (childElement.toString().trim()) {
          // By default, this attribute has "full" value.
          childElement.attr('markedForKeeping', 'full')
        }
        if (mask.steps[stepNumber + 1]) {
          // However, when there are more steps, we marks it to be partially kept.
          childElement.attr('markedForKeeping', 'partial')
          apply(childElement, mask, stepNumber + 1)
        }
      })
    }
  }

  function cleanup (element) {
    element.childNodes().forEach((childNode) => {
      const keepAttr = childNode.attr('markedForKeeping')
      if (!keepAttr) {
        childNode.remove()
      } else {
        if (keepAttr.value() === 'partial') {
          // If the child node is marked as partial, we need to clean its children.
          cleanup(childNode)
        }
        keepAttr.remove()
      }
    })
  }

  return async (context, next) => {
    let selector = context.query.select
    if (!selector) {
      return next()
    }

    // Let the XML fetched by downstream middleware(s).
    await next()

    let xmlDoc = parseXml(context.body)
    const homeLink = xmlDoc.get('/SAM/navigation/link[@id = /SAM/page/navigation/breadcrumb[position() = 2]/@link-id]')
    if (homeLink) {
      const siteNode = xmlDoc.get(`/SAM/sites/site[@root-pageid = ${homeLink.attr('id').value()}]`)

      selector = await template(selector, {
        'SITE': siteNode,
        'HOME': homeLink
      })
    }

    debug(`Select /SAM/${selector}`)
    let mask = CACHE[selector]
    if (!mask) {
      mask = XPath.parse(selector)
      CACHE[selector] = mask
    }

    apply(xmlDoc, mask)
    cleanup(xmlDoc)

    context.body = xmlDoc.toString()
  }
}
