/* jslint         indent  : 2,    maxerr   : 50,
  esnext : true, -W030   : true, node     : true
*/
const debug = require('debug')('SAM:auth')

const sql = require('mssql')
const jwt = require('jsonwebtoken')
const crypto = require('crypto')

const ERROR_MSG = `The user ID or password you have entered is not valid.`

/**
 * [description]
 * @param  {String} options.uri           The database URL to connect to.
 * @param  {String} options.secret        The secret to use to sign the JWT.
 * @param  {NumericDate} options.duration The token expieration time, either in seconds, or a string like '1h'.
 * @return {[type]}                       The middleware.
 */
module.exports = ({
    database,
    secret,
    expiresIn,
    cookie,
    issuer,
    audience,
    subject,
    username,
    password
  } = {}) => {

  // Reassign constants to avoid name conflict.
  const USERNAME = username;
  const PASSWORD = password;

  const sign = function (payload, context, options) {
    // We always use the `expiresIn` option instead of `exp`.
    delete payload.exp

    Object.assign(payload, {
      iat: Math.floor(Date.now() / 1000),
      iss: issuer,
      aud: audience,
      sub: subject
    })

    const token = jwt.sign(payload, secret, {
      expiresIn: expiresIn || Number(process.env.AUTH_DURATION || 60 * 60)
    })

    // Usually, the JWT is normally provided in the `Authorization`
    // header, but since we only render template, we can't expect
    // that header to be set, so we use cookie instead. However, by
    // using JWT, we can later on allow access manually without login.
    cookie && context.cookies.set(cookie, token, {
      maxAge: expiresIn * 1000
    })
  }

  const login = async function (userid, pass) {
    await database
    debug(`Verify if the user ${userid} exists.`)

    let request = new sql.Request()
      .input('Username', sql.NVarChar, userid)
      .query('SELECT * FROM [User] WHERE Login = @Username')

    try {
      const result = await request
      const {recordset: [ user ]} = await request
      if (!user) {
        throw('Nonexistent user.')
      } else {
        // Generate a sample hash to know the length;
        let hasher = crypto.createHash('md5').update('')
        const hashLength = hasher.digest('hex').length
        hasher = crypto.createHash('md5')

        const hashed = user.Password
        const salt = hashed.substring(hashLength)
        const newHash = hasher.update(`${pass}${salt}`).digest('hex').toUpperCase() + salt

        if (newHash !== hashed) {
          throw('Wrong password.')
        } else {
          debug('Signing the JWT for the user.')
          return user
        }
      }
    } catch (err) {
      throw(err)
    }
  }

  return async (context, next) => {
    if (context.request.path === '/logoff') {
      debug('Logging off.')
      context.cookies.set(cookie, null)
      return context.response.redirect('/')
    }

    const user = context.state.user

    if (user) {
      // User is already verified by JWT, so we move forward.
      const { exp } = user

      if (Math.floor(Date.now() / 1000) <= exp) {
        // Refresh token.
        sign(user, context)
      }

      return next()
    } else if (USERNAME && PASSWORD) {
      // Username and password are provided at initialization, login.
      const user = await login(USERNAME, PASSWORD)
      const payload = {
        id: user.UserPK,
        login: user.Login
      }

      if (secret) {
        sign(payload, context)
      }

      context.state.user = payload

      return next()
    } else {
      // No user, we set the `id` params to 0 to display the login template.
      if (!context.params) {
        context.params = {}
      }
      context.params.id = 0
      // Also set user.id to 1 so the template renders with Guest account.
      context.state.user = { id: 1 }

      if (context.request.method === 'GET') {
        // When it's a GET request, we moves forward to display the login template.
        // @TOD: A better check.
        debug('No user, displaying login screen.')
        return next()
      }
    }

    // Handles a POST login request.
    if (!context.request.body) {
      return reload(context)
    }
    const { userid, password } = context.request.body

    if (!userid && !password) {
      return reload(context)
    }

    if (!userid || !password) {
      context.cookies.set('SAM:Message', ERROR_MSG)
      return reload(context)
    }

    try {
      const user = await login(userid, password)
      const payload = {
        id: user.UserPK,
        login: user.Login
      }

      if (secret) {
        sign(payload, context)
      }
      context.cookies.set('SAM:Message', null)
    } catch(err) {
      console.error(err)
      context.cookies.set('SAM:Message', ERROR_MSG)
    }

    return reload(context)
  }
}

function reload (context) {
  debug(`Reload page ${context.request.originalUrl}`)
  context.response.redirect(context.request.originalUrl)
}
