/* slint         indent  : 2,    maxerr   : 50,
  esnext : true, -W030   : true, node     : true
*/
const fs = require('fs')
const debug = require('debug')('SAM:XML:builder')

const sql = require('mssql')
const { parseXml } = require('../utils')

const STORED_PROCEDURES = {
  'page': 'bzsp_SAMPageData',
  'chunk': 'bzsp_SAMChunkData',
  'chunks': 'bzsp_SAMAllChunks',
  'root': 'bzsp_SAMRootNode',
  'metadata': 'bzsp_SAMMetaData',
  'presentation': 'bzsp_SAMPresentation',
  'sites': 'bzsp_SAMSites',
  'navigation': 'bzsp_SAMNavigation',
  'users': 'bzsp_SAMUsers',
  'groups': 'bzsp_SAMGroups',
  'roles': 'bzsp_SAMRoles',
  'permissions': 'bzsp_SAMPermissions',
  'objectmanagers': 'bzsp_SAMObjectManagers',
  'privileges': 'bzsp_SAMPrivileges',
  'chunkHistory': 'bzsp_SAMChunkHistory',
  'chunkRevision': 'bzsp_SAMChunkRevision',
  'documentData': 'bzsp_SAMDocumentData',
  'history': 'bzsp_samHistory'
}
const XML_KEY = 'XML_F52E2B61-18A1-11d1-B105-00805F49916B'
const HELP_MSG = 'http://support.brandextract.com/'
const VERSION = '3.0.0'
const TOSTRING_OPTIONS = {
  declaration: true,
  format: true
}

let timer

/**
 * Check whether the name matches the query.
 *
 * @param {string} name The name to check
 * @param {string} query The query name to check against.
 */
function matches(name, query) {
  if (!query) return false

  return ['true', '1', name].indexOf(query) > -1
        || query.indexOf(name) > -1
}

module.exports = (config = {}) => {
  const connection = config.database
  const cacheFolder = config.cacheFolder || ''

  /**
   * Middleware to store XML in `context.body`
   * @param  {Object}   context Connection context.
   * @param  {Function} next    Downstream middleware.
   * @return {void}             The result of downstream.
   */
  return async (context, next) => {
    timer = new Date()

    try {
      await connection
      debug(`DB Connection established after ${new Date() - timer}ms`)
    } catch(ex) {
      console.error(`DB Connection exception: ${ex}`)
    }

    sql.on('error', (err) => {
      context.throw(504, err)
    })

    context.params.version = VERSION

    const override = context.query.override
    let pageId = context.params.id
    pageId = parseInt(pageId)

    let user = context.state.user

    const defaultParams = {
      'PagePK': pageId,
      'UserFK': user.id,
      'ThisUse': 'admin'
    }

    let filePath = `${cacheFolder}/page-${pageId}.xml`
    let pageCacheExists = false
    let docXMLSAM, rootNode, pageNode

    try {
      debug(`Retrieving XML from file ${filePath}.`)
      // Keep the XML string in memory for cloning later.
      pageNode = fs.readFileSync(filePath, 'utf8')
      docXMLSAM = parseXml(pageNode)
      rootNode = docXMLSAM.get('/SAM')
      if (!user) {
        // Set a temporary user for SAM with a high ID to avoid conflict.
        context.state.user = { id: 1 }
      }
      pageCacheExists = true
    } catch (_err) {
      debug(`No XML file for page ${pageId} in cache - await next.`)
    }

    pageCacheExists = pageCacheExists && !matches('page', override)

    // Query the root node first if not exist in cache or requested to override.
    if (!pageCacheExists) {
      try {
        timer = new Date()
        let params = Object.assign({
          'MyHelp': context.query.help || HELP_MSG,
          'Developer': context.query.developer || 0,
          'Version': context.query.version || VERSION
        }, defaultParams)
        docXMLSAM = await runForXMLQuery('root', params)
        rootNode = docXMLSAM.get('/SAM')

        params = Object.assign({'ChunkPK': pageId}, defaultParams)
        let node = await getXMLData('page', params)
        rootNode.addChild(node)
        // The page node will be saved to file after the chunks are fetched.
        // We keep the XML string to convert to XML doc later instead of cloning.
        pageNode = docXMLSAM.toString(TOSTRING_OPTIONS)
        debug(`docXMLSAM created for page ${pageId} after ${new Date() - timer}ms`)
      } catch (err) {
        console.error(err)
        return context.throw(400, err)
      }
    }

    // Persists the current root node into
    pageNode = parseXml(pageNode)

    let requests, results

    // Populates the nodes.
    const nodeNames = [
      'privileges',
      'metadata',
      'presentation',
      'sites',
      'objectmanagers',
      'documentData'
    ]

    requests = nodeNames
    .map((nodeName) => {
      let node = undefined
      let filePath = `${cacheFolder}/${nodeName}.xml`

      if (!matches(nodeName, override)) {
        try {
          debug(`Retrieving ${nodeName} node from file ${filePath}.`)
          node = parseXml(fs.readFileSync(filePath, 'utf8'), `/${nodeName}`)
        } catch (err) {
          debug(`No file for ${nodeName} node at ${filePath}.`)
        }
      }
      if (node) {
        return node
      }

      // No file cache or override is set for this node.
      let obj = (['privileges'].indexOf(nodeName) > -1 ? pageId : undefined)
      let params = Object.assign({'ChunkPK': obj}, defaultParams)
      return getXMLData(nodeName, params)
      .then((node) => {
        fs.writeFileSync(filePath, node.toString(TOSTRING_OPTIONS), 'utf8')
        debug(`Retrieved ${nodeName} node for page ${pageId} and cached to ${filePath}`)

        return node
      })
    })

    try {
      timer = new Date()
      results = await Promise.all(requests)
      debug(`XML data retrieved for page ${pageId} after ${new Date() - timer}ms`)
    } catch (err) {
      console.error(err)
      return context.throw(400, err)
    }

    // We have to do this to ensure order of nodes.
    results.forEach((node) => {
      rootNode.addChild(node)
    })

    if (!pageCacheExists || matches('chunks', override)) {
      let chunkNodes = rootNode.find('/SAM/page/chunk[@id]')
      // Request full chunk data.
      requests = chunkNodes.map((node) => {
        const nodeId = node.attr('id').value()
        let params = Object.assign({
          'ChunkPK': nodeId
        }, defaultParams)
        return getXMLData('chunk', params)
        .then((chunk) => {
          const sequenceAttr = node.attr('sequence')
          if (sequenceAttr) {
            chunk.attr({'sequence': sequenceAttr.value()})
          }

          node.replace(chunk)

          node = pageNode.get(`/SAM/page/chunk[@id='${nodeId}']`)
          node.replace(chunk)
        })
      })

      try {
        timer = new Date()
        await Promise.all(requests)
        debug(`Chunk XML data received for page ${pageId} after ${new Date() - timer}ms`)
      } catch (err) {
        console.error(err)
        return context.throw(400, err)
      }

      // Save chunk nodes into page.
      fs.writeFileSync(`${cacheFolder}/page-${pageId}.xml`, pageNode.toString(TOSTRING_OPTIONS), 'utf8')
    }

    // Handle navigation data.
    let node = undefined
    let nodeName = 'navigation'
    filePath = `${cacheFolder}/${nodeName}.xml`

    if (!matches(nodeName, override)) {
      try {
        debug(`Retrieving ${nodeName} node from file ${filePath}.`)
        node = parseXml(fs.readFileSync(filePath, 'utf8'), `/${nodeName}`)
      } catch (err) {
        debug(`No file for ${nodeName} node at ${filePath}.`)
      }
    }

    if (node) {
      rootNode.addChild(node)
    } else {
      const homeNode = rootNode.get('/SAM/page/navigation/breadcrumb[@depth=\'0\']')
      if (homeNode) {
        const homeId = homeNode.attr('link-id').value()
        const siteNode = rootNode.get(`/SAM/sites/site[@root-pageid = '${homeId}']`)
        const siteId = siteNode.attr('id').value()
        let params = Object.assign({
          'ChunkPK': siteId,
          'HomePagePK': homeId
        }, defaultParams)
        await getXMLData('navigation', params)
        .then((node) => {
          rootNode.addChild(node)
          fs.writeFileSync(filePath, node.toString(TOSTRING_OPTIONS), 'utf8')
          debug(`Retrieved ${nodeName} node for page ${pageId} and cached to ${filePath}`)
        })
      }
    }

    context.body = docXMLSAM
    context.type = 'text/xml'

    return next()
  }
}

/**
 * Retrieves XML data of a node in a page.
 *
 * It first looks into cache table, and only run stored
 * procedure for the node if cache stales.
 *
 * @param {String}  type            Node type to query.
 * @param {Int}     params.PagePK   The page ID.
 * @param {Int}     params.ChunkPK  The target ID if any.
 * @param {Int}     params.UserFK   The user performing the query.
 * @param {String}  params.ThisUse  The directive to use for querying.
 * @return {Object}                 The XML node
 *
 * Other params are passed to `runForXMLQuery/2` function.
 */
async function getXMLData (type, params) {
  const { PagePK, ChunkPK, UserFK } = params

  debug(`Start getXMLData(${type}, ${PagePK}, ${ChunkPK})`)

  let request = new sql.Request()
      .input('CacheType', sql.NVarChar, type)
      .input('UserFK', sql.Int, UserFK)

  const hasObjectFK = (ChunkPK || ChunkPK === 0)

  let query = 'SELECT * FROM Cache WHERE CacheType = @CacheType AND UserFK = @UserFK'
  if (hasObjectFK) {
    request.input('ObjectFK', sql.Int, ChunkPK)
    query += ' AND ObjectFK = @ObjectFK'
  }

  return request.query(query)
  .then(({recordset}) => {
    if (!recordset.length) {
      debug(`No cache for ${type}`)
      return runForXMLQuery(type, params)
            .then((root) => {
              // We don't store root node in cache.
              if (type === 'root') {
                return root
              }

              debug(`Start caching XML for ${type}`)

              // The cache only stores the actual node XML, not from the /SAM parent.
              let node = root.get(`/SAM/${type}`)
              // The request already have parameters before, we just add a new one.
              request.input('CacheData', sql.NVarChar, node.toString())

              query = 'INSERT INTO Cache (CacheData, UserFK, CacheType'
              if (hasObjectFK) query += ', ObjectFK'
              query += ') VALUES(@CacheData, @UserFK, @CacheType'
              if (hasObjectFK) query += ', @ObjectFK'
              query += ')'

              return request.query(query).then(() => node)
            })
    } else {
      debug(`Return cached data for ${type}`)
      const [ {CacheData} ] = recordset
      return parseXml(CacheData, `/${type}`)
    }
  })
}

/**
 * Executes stored procedure and save to cache
 *
 * @param {String}  type            Node type to query.
 * @param {Int}     params.PagePK   The page ID.
 * @param {Int}     params.ChunkPK  The target ID if any.
 * @param {Int}     params.UserFK   The user performing the query.
 * @param {String}  params.ThisUse  The directive to use for querying.
 * @return {Object}                 The XML node
 *
 * There can be other params depending on the query.
 */
async function runForXMLQuery (type, params) {
  debug(`Start runForXMLQuery(${type}, ${params.PagePK}, ${params.ChunkPK})`)

  let request = new sql.Request()

  if (type === 'navigation') {
    let pageRequest = new sql.Request()
        .input('PagePk', sql.Int, params.HomePagePK)
        .query('SELECT * FROM [Page] WHERE PagePK = @PagePk')

    const {recordset: [ {LeftPtr, RightPtr} ]} = await pageRequest

    delete params.HomePagePK

    request.input('myLeft', sql.Int, LeftPtr)
           .input('myRight', sql.Int, RightPtr)
  }

  for (const name in params) {
    const value = params[name]
    const dataType = getType(value)
    request.input(name, sql[dataType], value)
  }

  // Some requests require `ChunkPK` param, even if it's undefined.
  request.input('ChunkPK', sql.Int, params.ChunkPK)

  let storedProcedure = STORED_PROCEDURES[type]

  return request.execute(storedProcedure)
    .then(function({recordset: [root]}) {
      return parseXml(root[XML_KEY])
    })
}

function getType (value) {
  if (typeof value === 'string') return 'NVarChar'
  if (Number.isInteger(value)) return 'Int'
  // @TODO: What are other types?
  return 'Int'
}
